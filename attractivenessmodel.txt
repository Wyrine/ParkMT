Each building has a population at time t, pop(t,building); we get this from out data, I'll let someone else define pop(t)
Define a value dTotal for each building. dTotal(building) is the sum of distance from building to lot1, from building to lot 2 . . . from building to lot n. // [sum(distance(building, lot)]
We will predict that each building has an amount of people parked at a lot at time t defined as such:
parked(t,building,lot) = pop(t,building) * distance(building) / dTotal(building)
Now we will define a value for a modified lot capacity, availableParking(t,lot)
availableParking(t,lot) = capacity(lot) - sum(parked(t,building,lot))    // sum over every building here

We will define a function distancePreference(building,lot)based on distance from lot to building that will have domain from 0 to 1 and range r >= 0.
This one is kind of arbitrary and I don't know quite what to pick. Options include a logistic function and an inverse r one.
Option 1: 1/(A*distance(lot,building)/5280.0 + 1.0) ;        A = 4.0;           // A is a variable that can be tinkered with. Maybe pick another value
Option 2: 1/(1 + exp(A*distance(lot,building)/5280.0 + 1.0); A = .75;

finally, the value we are looking for! The atractiveness of a lot. A perfect lot would have a score of 1.

let attractiveness(lot,building,t) = distancePreference(building,lot) * availableParking(t,lot) / capacity(lot)


Functions needed:
attractiveness(lot,building,t)    = distancePreference(building,lot) * availableParking(t,lot) / capacity(lot)
distancePreference(building,lot)  = ?     // needs to be explored more
availableParking(t,lot)           = capacity(lot) - sum(parked(t,building,lot))
parked(t,building,lot) = pop(t,building) * distance(building) / dTotal(building)
dTotal(building) = sum(distance(building, lot))
distance(building, lot) = lol good luck ry guy
pop(t,building) = ? // This is why we scraped data. This is probably the toughest part of this function, if anyone want's to talk about it, let's get it on.
